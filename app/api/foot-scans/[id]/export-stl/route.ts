import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth-options';
import { prisma } from '@/lib/db';

// Generate STL binary content from foot measurements
function generateFootSTL(
  length: number, // mm
  width: number,  // mm
  archHeight: number, // mm
  side: 'left' | 'right'
): Buffer {
  const mirror = side === 'right' ? -1 : 1;
  const segX = 20;
  const segZ = 40;
  const thickness = 8; // mm base thickness for insole

  // Generate vertices for top surface
  const topVertices: [number, number, number][] = [];
  const bottomVertices: [number, number, number][] = [];

  for (let iz = 0; iz <= segZ; iz++) {
    const tz = iz / segZ;
    for (let ix = 0; ix <= segX; ix++) {
      const tx = ix / segX;

      // Width profile
      let widthFactor: number;
      if (tz < 0.15) {
        widthFactor = 0.55 + tz * 2.0;
      } else if (tz < 0.6) {
        widthFactor = 0.85 + (tz - 0.15) * 0.33;
      } else if (tz < 0.75) {
        widthFactor = 1.0;
      } else {
        widthFactor = 1.0 - (tz - 0.75) * 2.5;
      }
      widthFactor = Math.max(0.15, widthFactor);

      const halfW = (width * widthFactor) / 2;
      const x = mirror * (-halfW + tx * halfW * 2);
      const z = -length / 2 + tz * length;

      // Top surface (arch shape)
      let y = 0;
      const archFactor = Math.sin(tz * Math.PI);
      const edgeFactor = 1.0 - Math.abs(tx - 0.5) * 2;
      y += archHeight * archFactor * edgeFactor * 0.5;
      if (tz < 0.2) {
        y += 3 * (1.0 - tz / 0.2) * (1.0 - Math.abs(tx - 0.5) * 2);
      }
      if (tz > 0.6 && tz < 0.85) {
        const ballFactor = 1.0 - Math.abs((tz - 0.725) / 0.125);
        y += 1.5 * ballFactor * (1.0 - Math.abs(tx - 0.5) * 1.5);
      }

      topVertices.push([x, y + thickness, z]);
      bottomVertices.push([x, 0, z]);
    }
  }

  // Count triangles: top surface + bottom surface + side walls
  const topTriangles = segX * segZ * 2;
  const bottomTriangles = segX * segZ * 2;
  // Side walls: left edge + right edge + front + back
  const sideTriangles = (segZ * 2 + segX * 2) * 2;
  const totalTriangles = topTriangles + bottomTriangles + sideTriangles;

  // STL binary format: 80 byte header + 4 byte count + 50 bytes per triangle
  const bufferSize = 80 + 4 + totalTriangles * 50;
  const buffer = Buffer.alloc(bufferSize);
  let offset = 0;

  // Header (80 bytes)
  const header = `STL Binary - Foot Model (${side}) - Generated by Clinic System`;
  buffer.write(header.padEnd(80, '\0'), 0, 80, 'ascii');
  offset = 80;

  // Triangle count
  buffer.writeUInt32LE(totalTriangles, offset);
  offset += 4;

  // Helper to write a triangle
  function writeTriangle(
    nx: number, ny: number, nz: number,
    v1: [number, number, number],
    v2: [number, number, number],
    v3: [number, number, number]
  ) {
    // Normal
    buffer.writeFloatLE(nx, offset); offset += 4;
    buffer.writeFloatLE(ny, offset); offset += 4;
    buffer.writeFloatLE(nz, offset); offset += 4;
    // Vertex 1
    buffer.writeFloatLE(v1[0], offset); offset += 4;
    buffer.writeFloatLE(v1[1], offset); offset += 4;
    buffer.writeFloatLE(v1[2], offset); offset += 4;
    // Vertex 2
    buffer.writeFloatLE(v2[0], offset); offset += 4;
    buffer.writeFloatLE(v2[1], offset); offset += 4;
    buffer.writeFloatLE(v2[2], offset); offset += 4;
    // Vertex 3
    buffer.writeFloatLE(v3[0], offset); offset += 4;
    buffer.writeFloatLE(v3[1], offset); offset += 4;
    buffer.writeFloatLE(v3[2], offset); offset += 4;
    // Attribute byte count
    buffer.writeUInt16LE(0, offset); offset += 2;
  }

  // Compute face normal
  function computeNormal(
    v1: [number, number, number],
    v2: [number, number, number],
    v3: [number, number, number]
  ): [number, number, number] {
    const ax = v2[0] - v1[0], ay = v2[1] - v1[1], az = v2[2] - v1[2];
    const bx = v3[0] - v1[0], by = v3[1] - v1[1], bz = v3[2] - v1[2];
    const nx = ay * bz - az * by;
    const ny = az * bx - ax * bz;
    const nz = ax * by - ay * bx;
    const len = Math.sqrt(nx * nx + ny * ny + nz * nz) || 1;
    return [nx / len, ny / len, nz / len];
  }

  const idx = (iz: number, ix: number) => iz * (segX + 1) + ix;

  // Top surface triangles
  for (let iz = 0; iz < segZ; iz++) {
    for (let ix = 0; ix < segX; ix++) {
      const a = topVertices[idx(iz, ix)];
      const b = topVertices[idx(iz, ix + 1)];
      const c = topVertices[idx(iz + 1, ix)];
      const d = topVertices[idx(iz + 1, ix + 1)];
      let n = computeNormal(a, c, b);
      writeTriangle(n[0], n[1], n[2], a, c, b);
      n = computeNormal(b, c, d);
      writeTriangle(n[0], n[1], n[2], b, c, d);
    }
  }

  // Bottom surface triangles (reversed winding)
  for (let iz = 0; iz < segZ; iz++) {
    for (let ix = 0; ix < segX; ix++) {
      const a = bottomVertices[idx(iz, ix)];
      const b = bottomVertices[idx(iz, ix + 1)];
      const c = bottomVertices[idx(iz + 1, ix)];
      const d = bottomVertices[idx(iz + 1, ix + 1)];
      let n = computeNormal(a, b, c);
      writeTriangle(n[0], n[1], n[2], a, b, c);
      n = computeNormal(b, d, c);
      writeTriangle(n[0], n[1], n[2], b, d, c);
    }
  }

  // Side walls - left edge (ix=0)
  for (let iz = 0; iz < segZ; iz++) {
    const tl = topVertices[idx(iz, 0)];
    const bl = bottomVertices[idx(iz, 0)];
    const tn = topVertices[idx(iz + 1, 0)];
    const bn = bottomVertices[idx(iz + 1, 0)];
    let n = computeNormal(tl, bl, tn);
    writeTriangle(n[0], n[1], n[2], tl, bl, tn);
    n = computeNormal(tn, bl, bn);
    writeTriangle(n[0], n[1], n[2], tn, bl, bn);
  }

  // Side walls - right edge (ix=segX)
  for (let iz = 0; iz < segZ; iz++) {
    const tr = topVertices[idx(iz, segX)];
    const br = bottomVertices[idx(iz, segX)];
    const tn = topVertices[idx(iz + 1, segX)];
    const bn = bottomVertices[idx(iz + 1, segX)];
    let n = computeNormal(tr, tn, br);
    writeTriangle(n[0], n[1], n[2], tr, tn, br);
    n = computeNormal(tn, bn, br);
    writeTriangle(n[0], n[1], n[2], tn, bn, br);
  }

  // Side walls - front (iz=0)
  for (let ix = 0; ix < segX; ix++) {
    const tl = topVertices[idx(0, ix)];
    const bl = bottomVertices[idx(0, ix)];
    const tr = topVertices[idx(0, ix + 1)];
    const br = bottomVertices[idx(0, ix + 1)];
    let n = computeNormal(tl, tr, bl);
    writeTriangle(n[0], n[1], n[2], tl, tr, bl);
    n = computeNormal(tr, br, bl);
    writeTriangle(n[0], n[1], n[2], tr, br, bl);
  }

  // Side walls - back (iz=segZ)
  for (let ix = 0; ix < segX; ix++) {
    const tl = topVertices[idx(segZ, ix)];
    const bl = bottomVertices[idx(segZ, ix)];
    const tr = topVertices[idx(segZ, ix + 1)];
    const br = bottomVertices[idx(segZ, ix + 1)];
    let n = computeNormal(tl, bl, tr);
    writeTriangle(n[0], n[1], n[2], tl, bl, tr);
    n = computeNormal(tr, bl, br);
    writeTriangle(n[0], n[1], n[2], tr, bl, br);
  }

  return buffer;
}

// GET - Export foot scan as STL
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const session = await getServerSession(authOptions);
    if (!session?.user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { id } = params;
    const userId = (session.user as any).id;

    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { id: true, role: true, clinicId: true }
    });

    if (!user || user.role === 'PATIENT') {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 });
    }

    const footScan = await prisma.footScan.findUnique({ where: { id } });

    if (!footScan) {
      return NextResponse.json({ error: 'Foot scan not found' }, { status: 404 });
    }

    if (user.clinicId !== footScan.clinicId) {
      return NextResponse.json({ error: 'Access denied' }, { status: 403 });
    }

    const { searchParams } = new URL(request.url);
    const side = (searchParams.get('side') || 'left') as 'left' | 'right';

    const footLength = (side === 'left' ? footScan.leftFootLength : footScan.rightFootLength) || 260;
    const footWidth = (side === 'left' ? footScan.leftFootWidth : footScan.rightFootWidth) || 100;
    const archHeight = (side === 'left' ? footScan.leftArchHeight : footScan.rightArchHeight) || 25;

    const stlBuffer = generateFootSTL(footLength, footWidth, archHeight, side);

    const filename = `${footScan.scanNumber}-${side}-foot.stl`;

    return new NextResponse(new Uint8Array(stlBuffer), {
      status: 200,
      headers: {
        'Content-Type': 'application/sla',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': stlBuffer.length.toString(),
      }
    });

  } catch (error) {
    console.error('Error exporting STL:', error);
    return NextResponse.json({ error: 'Failed to export STL' }, { status: 500 });
  }
}
